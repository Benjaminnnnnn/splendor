Let’s keep it social and lightweight. Build a friendship + chat backend in TypeScript/Express/Socket.IO with SQLite tables: friendships (user_id_1, user_id_2, created_at, UNIQUE pair), friend_requests (from_user_id, to_user_id, created_at, UNIQUE pair), chat_messages (id, sender_id, sender_name, recipient_id?, game_id?, type 'direct' | 'group', content, timestamp). FriendshipRepository should sendRequest (block self, duplicates, reverse duplicates, already friends), acceptRequest (transaction: delete request, insert friendship with sorted ids), rejectRequest, removeFriendship, getFriends(userId), areFriends(userId1,userId2), hasRequest, getFriendCount, getPendingRequests.

ChatRepository persists only direct messages and exposes saveDirectMessage (validate type/recipient), getDirectMessageHistory(userId1,userId2, limit default 50, chronological), and getUserConversations grouped by peer. SocketManager just maps userId -> socketId.

ChatService leans on FriendshipService for authorization: createDirectMessage throws if not friends; createGroupMessage just builds an object (no persistence). Register/unregister sockets via SocketManager; deliver DMs via recipient socket if online and echo to sender.

Socket layer behavior: on 'chat:register', stash userId/username on socket and in SocketManager; on 'chat:send-message', if type=group require gameId and broadcast to room gameId; if type=direct require recipientId and friendship pass-through via ChatService; emit 'chat:new-message'. Support 'chat:typing' to game room or recipient; on disconnect, unregister.

REST under /api/chat with authenticateToken: GET /users/:userId/friends, POST /users/:userId/friends, POST /users/:userId/friends/accept, POST /users/:userId/friends/reject, GET /users/:userId/friends/requests, DELETE /users/:userId/friends/:friendId, GET /users/:userId/friends/:friendId/check. Chat history endpoint GET /users/:userId/conversations/:peerId?limit=50 (auth required) should 403 if req.user.userId mismatches or users aren’t friends. Controllers can call UserService to enrich friend lists and emit friend:request, friend:added, friend:request-rejected socket events.

Frontend vibe: chatServiceClient wraps all friendship APIs plus DM history; socketService emits chat:register with auth user id/username and listens for chat:new-message, friend:added, friend:request, friend:request-rejected. ChatPanel tabs: group chat (per gameId), DMs (friend list + load history + unread counts), friend requests (accept/reject), add friends (search via userServiceClient then send request). Only friends can DM; show friendly errors on disconnect/unauthorized. Group chat uses MessageType.GROUP with game room join; DMs use MessageType.DIRECT with sender/recipient metadata.

Skim the unit, integration, property-ish, and e2e tests for chat/friendship. What edge cases are missing? Please add edge-only tests: unit , self friend requests blocked, duplicate and reverse-duplicate requests rejected, accepting non-existent requests throws, DMs blocked when not friends, message history stays chronological, sockets unregister on disconnect. Integration/e2e , auth mismatch returns 403 on history, friend:request/added/rejected events fire to the right sockets. Property-ish , random socket registration/unregistration never leaves stale mappings. Mock Socket.IO and repos to keep it focused.
